# 쓰레드 이진 트리 (Thread Binary Tree)
기존에 이진트리의 순회방법에는 문제가 있다.  일단 시스템 스택을 이용해 재귀적인 호출을 한다.  
하지만 스레드 이진트리는 스택을 이용하지않고 포인터를 이용해 순회하는 방법인데

이렇게 하면 순회의 시간을 단축시킬 수 있다.


쓰레드 이진 트리 (Thread Binary Tree) 는 **중위순회** 를 기본개념으로하며,  
단말 노드(Leaf Node) 의 **NULL 링크를 이용** 한다.

기본적인 일반화 공식을 살펴보자

```
    @
  /   \
@       @  
       /  \
      @    @

'@' 를 노드라고 한다면    

n 개의 노드가있을 때

총 링크는           2n  개
NULL이 아닌링크     n-1  개
NULL인 링크        n+1  개

사실상 단말노드도 left 와 right 이 NULL 로 되어있으므로 개수로 세줘야한다.
```
여기서 등장한것이 `n + 1` 개의 남는 링크를 이용해 효율적으로 사용하자! 이다.

다시말해, 중위 순회시에 후속 노드인 중위 후속자(Inorder Successor) 를 저장시켜놓은 트리가  
 **스레드 이진 트리 (Thread Binary Tree)** 이다.

(중위후속자의 뜻은 아래에서 설명한다)


![이미지](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F22245833596872F712BADF)

중위 순회를 한다하면 트리의 순회에서 배웠듯이  
`L D R` 순서로 방문하게된다.  

그렇기때문에 `C B D A F E G` 순서로 가는데

여기서 `C` 를 방문 후 `B` 로 넘어가게 되는데, 이 때 `중위후속자(Inorder Successor)` 가 `B` 가 된다.

### 중위후속자란 무엇인가요?

중위 후속자란  
중위 순회 순서에서 그 다음에 이어질 차례인 노드인 것이다.



하지만 기존에 사용하던 구조체로 중위 후속자로 쓰기엔 다음과같은 문제가 있다.  
*
NULL 링크에 스레드를 저장한다면, `중위후속자` 인지, `자식노드` 인지 구별이 안
됨

그렇기 때문에 다음과 같은 **구조체 재정의** 가 필요하다.

```c
typedef struct TreeNode {
  element data;
  struct TreeNode * left;
  struct TreeNode * right;
  int isThread; // 추가
} TreeNode;
```
### int isThread 가 뭔가요?
`isThread` 는 `true(1)` 와 `false(0)` 로 값이 정해진다.  

**true** 인 경우는 `TreeNode * right` 은 중위후속자를 가리키고,  
**false** 인 경우는 `TreeNode * right` 이 오른쪽 자식노드를 가리킨다.


### 왜 하필 하나만 쓰고 굳이 `TreeNode * right` 을 쓰나요?
기본적으로 중위순회는 `L D R` 순서로 간다.  
즉, 왼쪽서브트리 -> 데이터읽기 -> 오른쪽서브트리 순서로 가는데

오른쪽 서브트리는 가장 나중에 방문하게 되기때문에 `right` 을 쓴다


### 노드 n 의 중위후속자를 반환하는 함수를 만들자!
**함수이름**  
`findThreadSuccessor()`

#### 알고리즘
```
1.  해당노드의 '오른쪽 자식노드' 의 isThread 가 true 인가?
    해당노드의 '오른쪽 자식노드' 가 NULL 인가?
      1-1. 둘중 하나가 true 라면, 오른쪽 자식노드 반환 (함수종료)
      1-2. 둘다 아닐경우 계속 진행 (함수진행)

2.  해당노드의 '오른쪽 자식노드' 가 NULL 이 아니라면,
    왼쪽서브트리가 존재하므로 왼쪽으로 계속 이동
```
음... 좀 복잡할 수 있는데 차근차근 설명을 해본다.

**1번의 첫번째 줄**  
단말노드의 중위후속자가 존재하는 경우  

**1번의 두번째 줄**  
이것은 가장 오른쪽 노드일 경우 탐색이 끝났다는것임  
가령, 위의 그림에서 `G` 일 경우를 말하는것  
중위순회는 `L D R` 순서이므로 `R` 의 순회도 끝난것임  
아래의 스레드중위순회 함수를 조금있다가 보면 **NULL 일경우 순회가 종료됨** 을 알 수 있음

**2번의 경우**  
일단, 2번까지 왔다는것은 `isThread` 가 false 인 경우이니  
왼쪽 서브트리가 존재한다는것이다. 그러므로 왼쪽서브트리의 끝까지 이동해준다.

여기서 잘 이해가 안갈 수 있는데
```
[추가설명]
2번의 경우는 어떤경우냐면 위의 그림에서
A 에서 E로 갈때
E 에서 isTread 는 false 이니 왼쪽서브트리로 이동하면
F 가 된다.

이해가 안되면 위의그림을 바탕으로 차근차근 해보면 무슨말인지 이해가 갈것이다.
필자도 이해가안되어 그림으로 그리면서 이해했...
```

### 스레드 이진트리의 중위순회 함수를 만들자!
**함수이름**  
`threadInorder()`

#### 알고리즘
```
1. 루트노드를 입력받고
2. 가장 왼쪽 노드로 이동     L
3. 해당 데이터를 읽는다      D
4. 중위후속자가 존재할때까지 찾는다.
   중위후속자가 없다는것은 가장 오른쪽노드이므로 종료
```

사실상 중위순회이지만 스레드에 의해 `L D 중위후속자` 의 루프를 돌게된다


자세한건 코드를 통해 확인하는것이 좋다.






#### 참고문서
[http://mattlee.tistory.com/29](http://mattlee.tistory.com/29)
